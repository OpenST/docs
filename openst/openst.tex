\documentclass[12pt,a4paper]{article}

\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{upgreek}
\usepackage{paralist}

\newcommand{\A}{\mathcal{A}}
\newcommand{\OC}{\mathcal{O}}
\newcommand{\V}{\mathcal{V}}
\newcommand{\G}{\mathcal{G}}
% OSTblock
\newcommand{\B}{\mathcal{B}}
\newcommand{\BS}{\operatorname{BS}}
\newcommand{\BE}{\operatorname{BE}}
% State root
\newcommand{\SR}{\operatorname{SR}}
% Storage root
\newcommand{\SO}{\operatorname{SO}}
% OSTblock gas limit
\newcommand{\OL}{\operatorname{OL}}


\input{eth_header}
\graphicspath{ {./images/} }

\title{OpenST\\\sc\Large{a framework for building token economies}}
\author{\textbf{Benjamin Bollen, Martin Schenck}\\ for OpenST Foundation}
\date{OpenST v0.10 - May 2018}

\begin{document}

\maketitle

\begin{abstract}
We present improvements to the OpenST protocol.
OpenST is a framework powered by Ethereum to build token economies.
We lay out in detail two contributions, OpenST Mosaic and OpenST Gateway,
which work together to scale Ethereum.
OpenST Mosaic is a layer-2
% TODO finish abstract
\end{abstract}

%
% Section
%
\section{Introduction}

%OpenST is a holistic solution powered by Ethereum to scale Ethereum to.

%
% Section
%
\section{OpenST}

\subsection{Use Cases}

\subsubsection{BT}

\subsubsection{DApp}

%
% Section
%
\section{Related Work}

\paragraph{Verifiers' Dilemma}
\cite{verifiersdilemma}

\paragraph{Interblockchain Communication}
\cite{cosmos}

\paragraph{Casper FFG}
\cite{casperffg}

%
% Section
%
\section{Our Contribution}

%
% Section
%
\section{Openly Scaling Blockchains}

\subsection{OpenST Gateway}
\label{subsec:gateway}

OpenST Gateway enables chain-to-chain transfer of state objects.

% TODO are OSTblocks "checkpoints" on auxiliary?
\subsection{OpenST Mosaic}
\label{subsec:mosaic}
OpenST Mosaic enables chain-to-chain state transfer.
That allows us to secure an insecure chain's state on a secure chain.
We call the secure chain \emph{origin} $\OC$ and the insecure one \emph{auxiliary} $\A$.
In order to be blockchain proposal mechanism agnostic,
we layer Casper~\cite{casperffg} on top of any auxiliary chain.
We apply Casper to auxiliary the same way its application to Ethereum is described in the paper.
We assume origin to have at least two properties:
practical byzantine fault tolerance (PBFT)~\cite{pbft} and plausible liveness~\cite{casperffg}.
Furthermore, we assume origin to have a concept of finality or at least economic finality.

Mosaic consists of Mosaic nodes that observe both $\OC$ and $\A$
as well as a specific Gateway like the ones described in section~\ref{subsec:gateway}.
That means every Mosaic node runs a full node per chain,
an independent client software that observes both full nodes,
and there is one smart contract per chain that makes up the Gateway.

% TODO the following paragraph is misplaced, not all concepts are known
% TODO What does "verify" state mean?
In order to transfer and verify state, it is required to transfer state bi-directionally between auxiliary and origin.
% TODO what does finalise on origin mean
% TODO what does it give to finalise on origin?
That way, auxiliary can verify that its state has been finalised on origin and
the set of validators, that is tracked on origin, is also known to auxiliary.

% TODO *mosaic* validators?
% TODO what is state
\emph{Validators} are actors that vote on state that is transferred between the two chains.
% TODO what do we mean by similar
% TODO introduce slashing here?
In addition, on auxiliary, they take the role of the Casper~\cite{casperffg} validators.
Their deposit, however, is stored on origin.
Similarly to Casper, any validator's deposit rises and falls with rewards and penalties, respectively.
When we say "$\frac{2}{3}$ of validators", we equally refer to the deposit-weighted fraction.
However, there are different kinds of voting message types, as described below.

% TODO describe that OSTblock headers announce the set of validators for the following OSTblock
The set of validators needs to be able to change.
The logic is similar to that of Casper with the notable difference that, instead of dynasties, we use OSTblocks (described below).
When a potential validator sends a \emph{deposit message} on origin at OSTblock height $\alpha$,
then the validator $\upnu$ will join the validator set at OSTblock height $\alpha+2$.
% TODO a lot copied from Casper. OK? Required?
Analogous to Casper, we call $\alpha+2$ the validator's \emph{start OSTblock}, $\BS(\upnu)$.
If a validator $\upnu$'s withdraw message is included on origin's blockchain during an open OSTblock $\B_\alpha$,
it similarly leaves the set of validators at OSTblock height $\alpha+2$.
We call $\alpha+2$ the validator $\upnu$'s \emph{end OSTblock} $\BE(\upnu)$.

% TODO *mosaic* validators?
% TODO should we have different names for mosaic validators and "casper on origin" validators?
% TODO inparaenum not clear enough; maybe split it into paragraphs
Validators can vote on a number of events:
% TODO are these different kinds of validators?
\begin{inparaenum}[(a)]
	\item origin state transfers to auxiliary,
	\item checkpoint justifications on auxiliary, and
 	\item auxiliary state transfers to origin.
\end{inparaenum}
On auxiliary, checkpoints are justified and finalised by supermajority links as described in Casper.
Origin's (economical) finality is assumed as a given.
% TODO what is a commit?
Thus, when state is transferred between the two chains, a simple $\frac{2}{3}$ majority vote on that state commits it to the receiving chain.

\emph{OSTblocks} are a compressed representation of auxiliary's transactions.
% TODO are OSTblocks' transactions blocks or dynasties from auxiliary?
% TODO do OSTblocks include forks or only the canonical chain of auxiliary (redundant if we only store latest state)
Transactions in an OSTblock each represent one block of the auxiliary chain.
An OSTblock transaction represents the state change from the beginning of its associated block to the end of that block.
Therefore, OSTblocks are generated at a slower pace.
We call $\alpha$ the height of OSTblock $\B_\alpha$.
The next OSTblock, that points to $\B_\alpha$ in its header,
is OSTblock $\B_{\alpha+1}$ at height $\alpha+1$.
Due to the aforementioned compression of blocks on auxiliary,
% TODO clarify that "+m" means any number of blocks
$\B_\alpha$ may contain auxiliary blocks $b_{\A{}i}$ to $b_{\A{}i+m}$.

The OSTblock header of block $\B_\alpha$ at height $\alpha$ contains:
\begin{enumerate}
	\item A link to the previous OSTblock
	\item The signatures of the validators in $\V_\alpha$
	\item The state root of the last block of auxiliary that is contained within the OSTblock
	\item The set of validators for the next OSTblock, $\V_{\alpha+1}$
\end{enumerate}
The body of an OSTblock consists of all the transactions that make up the blocks on auxiliary that are contained within this OSTblock.
We do not store the body of an OSTblock on origin, only the header.
The body can be re-created at any time from the auxiliary chain and proven against auxiliary's state root that is securely stored on origin.

We consider an OSTblock \emph{closed,} when the full header with the state root from auxiliary is committed to origin.
We consider an OSTblock \emph{opened,} when the new OSTblock header has been transferred to auxiliary.

% TODO language whole paragraph; also duplicate
In order to be block proposal mechanism agnostic, we layer Casper~\cite{casperffg} on top of auxiliary.
% TODO missing context. Extend or move to validators paragraph above
Validators vote on supermajority links.
Auxiliary must follow Casper's fork choice rule.
% TODO missing context
Checkpoints get finalised.
The Mosaic validators can transfer the state of a finalised auxiliary checkpoint to origin.
% TODO language
A validator uses the Mosaic Gateway to transfer the state to origin.
On origin, a $\frac{2}{3	}$ majority vote is required by the validators in order to commit the state to origin.
% TODO how do we trigger this info back to aux?
The state is regarded economically finalised when the block that contains the commit is considered economically final on origin.

\begin{figure}[htb]
    \centering
	\includegraphics[width=\textwidth]{mosaic}
	\caption{
		\textbf{The Mosaic state transfer.}
		The closing of $\B_{\alpha-1}$ means that the finalised checkpoint $b_{\A{}i}$ is the last block of $\B_{\alpha-1}$.
		Even though the details of $\B_\alpha$ will not be known until the opening is transferred to $\A$,
		the first block in $\B_\alpha$ will be $b_{\A{}i+1}$.
		Once a checkpoint is finalised after the OSTgas limit has been reached,
		% TODO V or a Mosaic node? where's the difference?
		$\V$ will signal the closing of $\B_\alpha$ to $\OC$.
	}
	\label{fig:mosaic}
\end{figure}

% TODO extend this paragraph
On the auxiliary chain, \emph{OSTgas} is the equivalent to gas on Ethereum.
For transactions to be included in blocks on auxiliary, a fee is paid for the consumed OSTgas.

% TODO mention Gateways here or more appropriately in the introduction to mosaic
% TODO possibly move this further up
Validators are allowed to commit every finalised state from auxiliary to origin.
However, that may be infeasible from an economic viewpoint of the validators.
Therefore, we propose points on the auxiliary chain where the validators must close the OSTblock.
Whenever a certain fixed limit of OSTgas has been spent on auxiliary since the opening of the OSTblock,
the validators \emph{must} close the OSTblock at the next finalised auxiliary checkpoint.
If a validator does not vote to commit that checkpoint,
its deposit can be slashed.
The OSTgas limit is marked in figure~\ref{fig:mosaic} by the dashed line.

Actors on the auxiliary chain have an economic incentive to finalise their state on origin.
% TODO OSTgas to _which_ validators?
The block creators of auxiliary will pay a fraction of their earned OSTgas to the validators as a fee when the validators move the state to origin.
% TODO context and language
% TODO why?
Due to the OSTblocks, validators can only copy the state from auxiliary to origin after the state of origin has been copied to auxiliary.
Thus, validators are incentivised to close an OSTblock and open a new one in order to earn the OSTgas fee for the transfer of auxiliary's state.

% TODO extend paragraph on punishment
It must be possible to hold validators accountable if they misbehave.
In order to do so, anyone must be able to present proof of malicious actions on origin,
as the validators' deposits are stored there.
When a validator violates a slashing condition on auxiliary by making an illegal vote,
that fact is stored in the state of auxiliary.
Therefore, it can be proven against the state root of auxiliary.
Since the state root of auxiliary is available on origin,
the proof and the subsequent slashing can be carried out on origin as well.

% TODO extend paragraph on long range revisions
To prevent long range revisions, we apply the same rules that Casper applies:
after a validator leaves the set of validators, its deposit is kept for another four months.
Casper votes on auxiliary can only be carried out up to three months into the past.
That leaves one month headroom to blame an adversary on origin and get its deposit slashed.

%
% Section
%
\section{Securing Simple User Experience}

\subsection{Token Holder Contracts}

APIs; no need to follow the chain.

%
% Section
%
\section{Platform}

\subsection{Token Rules}

\subsection{OpenST Platform}

%
% Section
%
\section{Outlook}

\subsection{Neo and Cardano}

%
% Section
%
\section{Conclusion}

\bibliographystyle{naturemag}
\bibliography{openst}

\end{document}
